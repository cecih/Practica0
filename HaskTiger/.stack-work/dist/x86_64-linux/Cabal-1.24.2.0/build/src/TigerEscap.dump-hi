
==================== FINAL INTERFACE ====================
2017-09-10 01:13:30.444252 UTC

interface HaskTiger-0.1.0.0-1NjWJIneMSYKOEJS7DxzEs:TigerEscap 8002
  interface hash: eabfd98361690d86e5dfe15ede49b5f9
  ABI hash: be3ab7404785021ab907cee46df4141a
  export-list hash: 0525a7587fc1d6c8291a181539ee677d
  orphan hash: 1939b25c92744ade14ed98787e5dc3d6
  flag hash: 06c40cc884ff8f9031b7bc379f419cf3
  sig of: Nothing
  used TH splices: False
  where
exports:
  TigerEscap.bulkInsert
  TigerEscap.calcularEEsc
  TigerEscap.eappend
  TigerEscap.initSt
  TigerEscap.lookUpLvl
  TigerEscap.travDecs
  TigerEscap.travExp
  TigerEscap.travF
  TigerEscap.travVar
  TigerEscap.Dat
  TigerEscap.Depth
  TigerEscap.Env
  TigerEscap.Errores{TigerEscap.Interno TigerEscap.NotFound}
  TigerEscap.Escapator{TigerEscap.depth TigerEscap.insert TigerEscap.lookup TigerEscap.printEnv TigerEscap.raise TigerEscap.up TigerEscap.update}
  TigerEscap.Estado{TigerEscap.S env lvl}
  TigerEscap.Mini
  TigerEscap.SEstado{TigerEscap.Step e l}
module dependencies: TigerAbs TigerEnv TigerErrores TigerSymbol
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.1.0
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1 mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6
                      text-1.2.2.2@text-1.2.2.2-1cn50juu89QSL9QkUVcRY
                      transformers-0.5.2.0@transformers-0.5.2.0
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         text-1.2.2.2@text-1.2.2.2-1cn50juu89QSL9QkUVcRY:Data.Text
         text-1.2.2.2@text-1.2.2.2-1cn50juu89QSL9QkUVcRY:Data.Text.Show
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         text-1.2.2.2@text-1.2.2.2-1cn50juu89QSL9QkUVcRY:Data.Text
import  -/  TigerAbs 37f30c082077bd2ed6390df841315dcd
  exports: 3a90fdff097973025312591ea87ea06f
  ArrayExp 7c6004bec77ad7b20c1094cbfb154bea
  AssignExp 259c3fb661a9f3068a023131e417122e
  CallExp 3777da78b97e94d0f97bf2ee04166d29
  Dec 49b0f3859ea1d6fd105d2ffa68df9b08
  Exp 49b0f3859ea1d6fd105d2ffa68df9b08
  Field c8f49be9185ea6e5e9a3803802efa4d2
  FieldVar 6a02be9d8e8fdcee7fe9de68577dfe04
  ForExp ca7c606616d226aadf449f81ecae2b42
  FunctionDec db1f0236b7de4394ae2d008cb4a7ddc6
  IfExp be5b47495f73bd344ea9ecaae1815c9f
  LetExp f8a5d4844645c88eb477572b9e6a0639
  OpExp b4e8d3a2b6279e06f1722b41c2bf7eae
  Pos fb36cd90a03c4961c3dee20c15acb197
  RecordExp 1e2cafdad5d3455b18da8f6d557d9616
  SeqExp bae16e417ec33004818db54293be1b0e
  SimpleVar e3c21d1c10c72c3d0838f9eea3d52970
  SubscriptVar df74264abbd5b42cd5439e839c11fbb1
  Var 49b0f3859ea1d6fd105d2ffa68df9b08
  VarDec ce4e43233e2faeafe81422e0ecf76419
  VarExp 5fee89112f87f39262195521d470e563
  WhileExp f00aa17c77f57abd2ad83be174b01d1d
  printPos ca3b01c561c5187981dd3982f6b86bb7
import  -/  TigerEnv 96a7e22cd83b9e952dd764ecbdc108be
  exports: f849677415546cf37a0bf0a757f9fe16
import  -/  TigerErrores 0494bdc5e70a4f3b7e7f3cd2a8df36e7
  exports: 45cb60eadf487bb751c7c86293d60fdf
  Daemon 75602831f2e73bbe876cee9ba1b36693
  adder 4f800706bdeed60112516e9cbf6fe8eb
  derror fe7e39a3380282f89262090297bd072b
  internal aba20a74c059762137faa07a286cae0d
  notfound 603deea58ff4b8c69d50f4a4302da34c
import  -/  TigerSymbol 7f64bcc3e38a9378b34cbe06e8c0cb9e
  exports: 461431869c9d4f5bf206765437ddd561
  Symbol 9260f1c2b584be005733445adbd4fb0e
import  -/  base-4.9.1.0:Control.Monad a6784c5dab0d75c63dabec5a37843f98
import  -/  base-4.9.1.0:Data.Either 20b09ef8d0a5b74fdec011c40c1587f5
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.Functor.Identity 6ee67943d44d50091e12d22df04741f0
import  -/  base-4.9.1.0:Data.Maybe d876c4ffe4b3c43755a781e8ad860d88
import  -/  base-4.9.1.0:Data.Traversable 556020d7cf3c4a34a774600512918a37
import  -/  base-4.9.1.0:Debug.Trace a9edf3aec504f4423d8ba829ab373a25
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base d432f6875983131473086af8cb290590
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map.Strict 9d0c0962e53270a0a3fb5cb63723a381
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.Error.Class 635294424a2da8269902789f5c8bbe99
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.Except 3bb0e2598193c1ba00c9723945e93004
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.State 749dca8ca0e6625b32091d445bd92b01
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.State.Class 6d31234b0a911b56412061943d18b89e
import  -/  text-1.2.2.2@text-1.2.2.2-1cn50juu89QSL9QkUVcRY:Data.Text ef501398810147cc510ae8565b319c23
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Class 45530f1305724ee3931a9be21b40ca7e
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.State.Lazy 371607e50dde46b5f4103b3ab334a497
003025e886f60ce0b28f5423d839f1cc
  $dmraise ::
    TigerEscap.Escapator m => forall a. TigerSymbol.Symbol -> m a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(SLLLL)LLLLLLLL),1*U(1*U(1*U,A,A,A,A),A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, False)
                (\ @ (m :: * -> *) ($dEscapator :: TigerEscap.Escapator m) @ a ->
                 TigerErrores.derror
                   @ m
                   (TigerEscap.$p1Escapator @ m $dEscapator)
                   @ a) -}
2ce1adb168dae20860fee0e8582aa84f
  $fDaemonStateT :: TigerErrores.Daemon TigerEscap.Mini
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ TigerEscap.Mini
                  TigerEscap.$fDaemonStateT_$cderror
                  TigerEscap.$fDaemonStateT_$cadder
                  TigerEscap.$fDaemonStateT_$cnotfound
                  TigerEscap.$fDaemonStateT_$cdiffval
                  TigerEscap.$fDaemonStateT_$cinternal -}
2ce1adb168dae20860fee0e8582aa84f
  $fDaemonStateT1 ::
    TigerEscap.Mini a
    -> TigerSymbol.Symbol
    -> TigerEscap.Estado
    -> Data.Either.Either TigerEscap.Errores (a, TigerEscap.Estado)
  {- Arity: 3, Strictness: <C(S),1*C1(U)><L,1*U(U,U,U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: TigerEscap.Mini a)
                   (s :: TigerSymbol.Symbol)
                   (eta :: TigerEscap.Estado) ->
                 case w `cast`
                      (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <TigerEscap.Estado>_N
                           <Data.Either.Either TigerEscap.Errores>_R
                           <a>_N)
                        eta of wild {
                   Data.Either.Left l1
                   -> Data.Either.Left
                        @ TigerEscap.Errores
                        @ (a, TigerEscap.Estado)
                        (TigerEscap.eappend l1 s)
                   Data.Either.Right r
                   -> Data.Either.Right
                        @ TigerEscap.Errores
                        @ (a, TigerEscap.Estado)
                        r }) -}
2ce1adb168dae20860fee0e8582aa84f
  $fDaemonStateT2 ::
    TigerSymbol.Symbol
    -> TigerEscap.Estado
    -> Data.Either.Either TigerEscap.Errores (a, TigerEscap.Estado)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m1,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (x :: TigerSymbol.Symbol) (eta :: TigerEscap.Estado) ->
                 Data.Either.Left
                   @ TigerEscap.Errores
                   @ (a, TigerEscap.Estado)
                   (TigerEscap.Interno x)) -}
2ce1adb168dae20860fee0e8582aa84f
  $fDaemonStateT_$cadder ::
    TigerEscap.Mini a -> TigerSymbol.Symbol -> TigerEscap.Mini a
  {- Arity: 3, Strictness: <C(S),1*C1(U)><L,1*U(U,U,U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                TigerEscap.$fDaemonStateT1
                  `cast`
                (forall (a :: <*>_N).
                 <TigerEscap.Mini a>_R
                 ->_R <TigerSymbol.Symbol>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <TigerEscap.Estado>_N
                               <Data.Either.Either TigerEscap.Errores>_R
                               <a>_N)) -}
2ce1adb168dae20860fee0e8582aa84f
  $fDaemonStateT_$cderror :: TigerSymbol.Symbol -> TigerEscap.Mini a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m1,
     Unfolding: InlineRule (0, True, True)
                TigerEscap.$fDaemonStateT2
                  `cast`
                (forall (a :: <*>_N).
                 <TigerSymbol.Symbol>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <TigerEscap.Estado>_N
                               <Data.Either.Either TigerEscap.Errores>_R
                               <a>_N)) -}
2ce1adb168dae20860fee0e8582aa84f
  $fDaemonStateT_$cdiffval :: TigerSymbol.Symbol -> TigerEscap.Mini a
  {- Arity: 1, Strictness: <L,1*U(U,U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (x :: TigerSymbol.Symbol) ->
                 let {
                   x1 :: TigerSymbol.Symbol
                   = TigerSymbol.addStr TigerEscap.$fDaemonStateT_g1 x
                 } in
                 (\ (eta :: TigerEscap.Estado) ->
                  Data.Either.Left
                    @ TigerEscap.Errores
                    @ (a, TigerEscap.Estado)
                    (TigerEscap.Interno x1))
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <TigerEscap.Estado>_N
                           <Data.Either.Either TigerEscap.Errores>_R
                           <a>_N))) -}
2ce1adb168dae20860fee0e8582aa84f
  $fDaemonStateT_$cinternal ::
    TigerSymbol.Symbol -> TigerEscap.Mini a
  {- Arity: 1, Strictness: <L,1*U(U,U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (x :: TigerSymbol.Symbol) ->
                 let {
                   x1 :: TigerSymbol.Symbol
                   = TigerSymbol.addStr TigerEscap.$fDaemonStateT_g x
                 } in
                 (\ (eta :: TigerEscap.Estado) ->
                  Data.Either.Left
                    @ TigerEscap.Errores
                    @ (a, TigerEscap.Estado)
                    (TigerEscap.Interno x1))
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <TigerEscap.Estado>_N
                           <Data.Either.Either TigerEscap.Errores>_R
                           <a>_N))) -}
2ce1adb168dae20860fee0e8582aa84f
  $fDaemonStateT_$cnotfound ::
    TigerSymbol.Symbol -> TigerEscap.Mini a
  {- Arity: 1, Strictness: <L,1*U(U,U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (x :: TigerSymbol.Symbol) ->
                 let {
                   x1 :: TigerSymbol.Symbol
                   = TigerSymbol.addStr TigerEscap.$fDaemonStateT_g2 x
                 } in
                 (\ (eta :: TigerEscap.Estado) ->
                  Data.Either.Left
                    @ TigerEscap.Errores
                    @ (a, TigerEscap.Estado)
                    (TigerEscap.Interno x1))
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <TigerEscap.Estado>_N
                           <Data.Either.Either TigerEscap.Errores>_R
                           <a>_N))) -}
61e5643f4d493e1a811251e3baa1f490
  $fDaemonStateT_g :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Internal: "#) -}
be2836aaed4c3caaf67a7836aecbed5b
  $fDaemonStateT_g1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Different values: "#) -}
a6b08da20d971fd8ebe18ebc875973d7
  $fDaemonStateT_g2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Not found:"#) -}
1a28e4bddfed5e0884e7fcc76790746c
  $fEscapatorStateT :: TigerEscap.Escapator TigerEscap.Mini
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ TigerEscap.Mini
                  TigerEscap.$fDaemonStateT
                  TigerEscap.$fEscapatorStateT_$cp2Escapator
                  TigerEscap.$fEscapatorStateT_$cdepth
                  TigerEscap.$fEscapatorStateT_$cup
                  TigerEscap.$fEscapatorStateT_$cprintEnv
                  TigerEscap.$fDaemonStateT_$cderror
                  TigerEscap.$fEscapatorStateT_$cupdate
                  TigerEscap.$fEscapatorStateT_$clookup
                  TigerEscap.$fEscapatorStateT_$cinsert -}
d63ecaf1b5552e8690e42d9e1b7b6cd8
  $fEscapatorStateT1 ::
    TigerSymbol.Symbol
    -> GHC.Types.Bool
    -> TigerEscap.Mini a
    -> TigerEscap.Estado
    -> Data.Either.Either TigerEscap.Errores (a, TigerEscap.Estado)
  {- Arity: 4,
     Strictness: <L,1*U(U,U,U)><L,U><C(S),1*C1(U)><L,U(U,U)>,
     Unfolding: (\ @ a
                   (name :: TigerSymbol.Symbol)
                   (esc :: GHC.Types.Bool)
                   (m :: TigerEscap.Mini a)
                   (eta :: TigerEscap.Estado) ->
                 case m `cast`
                      (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <TigerEscap.Estado>_N
                           <Data.Either.Either TigerEscap.Errores>_R
                           <a>_N)
                        (case eta of wild { TigerEscap.S ds ds1 ->
                         TigerEscap.S
                           ds
                           (case name of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                            TigerEscap.$w$sgo4
                              @ (GHC.Types.Int, GHC.Types.Bool)
                              ww1
                              ww2
                              ww3
                              (ds, esc)
                              ds1 }) }) of wild {
                   Data.Either.Left l1 -> wild
                   Data.Either.Right r
                   -> Data.Either.Right
                        @ TigerEscap.Errores
                        @ (a, TigerEscap.Estado)
                        (case r of wild1 { (,) a1 s' -> a1 }, eta) }) -}
9a2c4af7c43caf2e0032de3cc76c887e
  $fEscapatorStateT10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "lvl = "#) -}
272ebaeffc779090937cf94f1054fdfc
  $fEscapatorStateT11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "S {"#) -}
8f4e20ac35fbd2e6a5c41e4750c3b5d4
  $fEscapatorStateT12 ::
    TigerEscap.Mini a
    -> TigerEscap.Estado
    -> Data.Either.Either TigerEscap.Errores (a, TigerEscap.Estado)
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U(U(U),U)>,
     Unfolding: (\ @ a
                   (m :: TigerEscap.Mini a)
                   (eta :: TigerEscap.Estado) ->
                 case m `cast`
                      (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <TigerEscap.Estado>_N
                           <Data.Either.Either TigerEscap.Errores>_R
                           <a>_N)
                        (case eta of wild { TigerEscap.S ds ds1 ->
                         TigerEscap.S
                           (case ds of wild1 { GHC.Types.I# x ->
                            GHC.Types.I# (GHC.Prim.+# x 1#) })
                           ds1 }) of wild {
                   Data.Either.Left l1 -> wild
                   Data.Either.Right r
                   -> Data.Either.Right
                        @ TigerEscap.Errores
                        @ (a, TigerEscap.Estado)
                        (case r of wild1 { (,) a1 s' -> a1 }, eta) }) -}
edc1a4ede35ab24ab6baebb40e3d3a70
  $fEscapatorStateT13 ::
    TigerEscap.Estado
    -> Data.Either.Either
         TigerEscap.Errores (GHC.Types.Int, TigerEscap.Estado)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(U,U)>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: TigerEscap.Estado) ->
                 Data.Either.Right
                   @ TigerEscap.Errores
                   @ (GHC.Types.Int, TigerEscap.Estado)
                   (case s1 of wild { TigerEscap.S ds ds1 -> ds }, s1)) -}
0370351dd8fc195fb73a579adebd0e7b
  $fEscapatorStateT14 ::
    GHC.Base.Functor
      (Control.Monad.Trans.State.Lazy.StateT
         s (Data.Either.Either TigerEscap.Errores))
  {- Unfolding: (\ @ s ->
                 Control.Monad.Trans.State.Lazy.$fFunctorStateT
                   @ (Data.Either.Either TigerEscap.Errores)
                   @ s
                   (Data.Either.$fFunctorEither @ TigerEscap.Errores)) -}
afc7979f5f4de9ac77ffe29bc91ffa83
  $fEscapatorStateT2 ::
    TigerSymbol.Symbol
    -> TigerEscap.Estado
    -> Data.Either.Either
         TigerEscap.Errores
         (GHC.Base.Maybe TigerEscap.Dat, TigerEscap.Estado)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U,U,U)><L,U(U,U)>m2,
     Unfolding: InlineRule (2, True, False)
                (\ (name :: TigerSymbol.Symbol) (eta :: TigerEscap.Estado) ->
                 Data.Either.Right
                   @ TigerEscap.Errores
                   @ (GHC.Base.Maybe TigerEscap.Dat, TigerEscap.Estado)
                   (case eta of wild { TigerEscap.S ds ds1 ->
                    TigerEscap.$fEscapatorStateT3
                      @ (GHC.Types.Int, GHC.Types.Bool)
                      name
                      ds1 },
                    eta)) -}
fd60cdecfa78074b89c8e7b2f4d3e894
  $fEscapatorStateT3 ::
    TigerSymbol.Symbol
    -> Data.Map.Base.Map TigerSymbol.Symbol a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U,U,U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: TigerSymbol.Symbol)
                   (w1 :: Data.Map.Base.Map TigerSymbol.Symbol a) ->
                 case w of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                 TigerEscap.$wpoly_go10 @ a ww1 ww2 ww3 w1 }) -}
39735991e728c0740bc1c57f82674c99
  $fEscapatorStateT4 ::
    TigerSymbol.Symbol
    -> GHC.Types.Bool
    -> TigerEscap.Estado
    -> Data.Either.Either TigerEscap.Errores ((), TigerEscap.Estado)
  {- Arity: 3, Strictness: <S,U(U,U,U)><L,U><S(LS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: TigerSymbol.Symbol)
                   (w1 :: GHC.Types.Bool)
                   (w2 :: TigerEscap.Estado) ->
                 case w of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                 case w2 of ww4 { TigerEscap.S ww5 ww6 ->
                 TigerEscap.$w$cupdate ww1 ww2 ww3 w1 ww5 ww6 } }) -}
7ddff90b63b37f6109e59e37f7e2cb9a
  $fEscapatorStateT5 ::
    TigerEscap.Estado
    -> Data.Either.Either TigerEscap.Errores ((), TigerEscap.Estado)
  {- Arity: 1, Strictness: <L,U(U(U),U)>,
     Unfolding: (\ (s1 :: TigerEscap.Estado) ->
                 (Debug.Trace.trace
                    @ (Control.Monad.Trans.State.Lazy.StateT
                         TigerEscap.Estado (Data.Either.Either TigerEscap.Errores) ())
                    (GHC.CString.unpackAppendCString#
                       "PrintEnv "#
                       (case s1 of ww { TigerEscap.S ww1 ww2 ->
                        TigerEscap.$w$cshowsPrec
                          0#
                          ww1
                          ww2
                          (GHC.Types.[] @ GHC.Types.Char) }))
                    TigerEscap.$fEscapatorStateT6
                      `cast`
                    (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                              <TigerEscap.Estado>_N
                              <Data.Either.Either TigerEscap.Errores>_R
                              <()>_N)))
                   `cast`
                 (Control.Monad.Trans.State.Lazy.N:StateT[0]
                      <TigerEscap.Estado>_N
                      <Data.Either.Either TigerEscap.Errores>_R
                      <()>_N)
                   s1) -}
06c5f2e28d454d678340469275935cfe
  $fEscapatorStateT6 ::
    TigerEscap.Estado
    -> Data.Either.Either TigerEscap.Errores ((), TigerEscap.Estado)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: TigerEscap.Estado) ->
                 Data.Either.Right
                   @ TigerEscap.Errores
                   @ ((), TigerEscap.Estado)
                   (GHC.Tuple.(), s1)) -}
f5659a8dbb4cd638a00ce625827408f4
  $fEscapatorStateT7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
f49edf6d54c0ad38ca9b71336b10568b
  $fEscapatorStateT8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "env = "#) -}
a228f936f0efdc766e4abf40fd101d32
  $fEscapatorStateT9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
5d369607a867dc2f542b491141b3ce1f
  $fEscapatorStateT_$cdepth :: TigerEscap.Mini TigerEscap.Depth
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(U,U)>m2,
     Unfolding: InlineRule (0, True, True)
                TigerEscap.$fEscapatorStateT13
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <TigerEscap.Estado>_N
                          <Data.Either.Either TigerEscap.Errores>_R
                          <GHC.Types.Int>_N)) -}
4a5603702bf7b48d545587cea7e4a7f6
  $fEscapatorStateT_$cinsert ::
    TigerSymbol.Symbol
    -> GHC.Types.Bool -> TigerEscap.Mini a -> TigerEscap.Mini a
  {- Arity: 4,
     Strictness: <L,1*U(U,U,U)><L,U><C(S),1*C1(U)><L,U(U,U)>,
     Unfolding: InlineRule (0, True, True)
                TigerEscap.$fEscapatorStateT1
                  `cast`
                (forall (a :: <*>_N).
                 <TigerSymbol.Symbol>_R
                 ->_R <GHC.Types.Bool>_R
                 ->_R <TigerEscap.Mini a>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <TigerEscap.Estado>_N
                               <Data.Either.Either TigerEscap.Errores>_R
                               <a>_N)) -}
46018beaf40741000f7a7d5b76d694dd
  $fEscapatorStateT_$clookup ::
    TigerSymbol.Symbol
    -> TigerEscap.Mini (GHC.Base.Maybe (GHC.Types.Int, GHC.Types.Bool))
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U,U,U)><L,U(U,U)>m2,
     Unfolding: InlineRule (0, True, True)
                TigerEscap.$fEscapatorStateT2
                  `cast`
                (<TigerSymbol.Symbol>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <TigerEscap.Estado>_N
                               <Data.Either.Either TigerEscap.Errores>_R
                               <GHC.Base.Maybe TigerEscap.Dat>_N)) -}
9c13fd5694951628545b9a6b795edbb3
  $fEscapatorStateT_$cp2Escapator :: GHC.Base.Monad TigerEscap.Mini
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (TigerEscap.$fEscapatorStateT_$s$fMonadStateT
                   @ TigerEscap.Estado) -}
89cfc6ea5c60cc4e39d43fade78e65f6
  $fEscapatorStateT_$cprintEnv :: TigerEscap.Mini ()
  {- Arity: 1, Strictness: <L,U(U(U),U)>,
     Unfolding: InlineRule (0, True, True)
                TigerEscap.$fEscapatorStateT5
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <TigerEscap.Estado>_N
                          <Data.Either.Either TigerEscap.Errores>_R
                          <()>_N)) -}
dacebef18c59b4d1b09ebad77364c7d1
  $fEscapatorStateT_$cup :: TigerEscap.Mini a -> TigerEscap.Mini a
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U(U(U),U)>,
     Unfolding: InlineRule (0, True, True)
                TigerEscap.$fEscapatorStateT12
                  `cast`
                (forall (a :: <*>_N).
                 <TigerEscap.Mini a>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <TigerEscap.Estado>_N
                               <Data.Either.Either TigerEscap.Errores>_R
                               <a>_N)) -}
9ef4fb7dd5b1be4ded2e0ea0a7078262
  $fEscapatorStateT_$cupdate ::
    TigerSymbol.Symbol -> GHC.Types.Bool -> TigerEscap.Mini ()
  {- Arity: 3, Strictness: <S,U(U,U,U)><L,U><S(LS),1*U(U,U)>,
     Unfolding: InlineRule (0, True, True)
                TigerEscap.$fEscapatorStateT4
                  `cast`
                (<TigerSymbol.Symbol>_R
                 ->_R <GHC.Types.Bool>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <TigerEscap.Estado>_N
                               <Data.Either.Either TigerEscap.Errores>_R
                               <()>_N)) -}
9a7e819a786fca4baff98f5a6fc97776
  $fEscapatorStateT_$dFunctor ::
    GHC.Base.Functor (Data.Either.Either TigerEscap.Errores)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (Data.Either.$fFunctorEither @ TigerEscap.Errores) -}
cbdee76dba3f22aa3778d608c7e13e99
  $fEscapatorStateT_$s$fApplicativeStateT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.State.Lazy.StateT
         s (Data.Either.Either TigerEscap.Errores))
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s (Data.Either.Either TigerEscap.Errores))
                  (TigerEscap.$fEscapatorStateT14 @ s)
                  (TigerEscap.$fEscapatorStateT_$s$fApplicativeStateT_$cpure @ s)
                  (TigerEscap.$fEscapatorStateT_$s$fApplicativeStateT_$c<*> @ s)
                  (Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$c*>
                     @ (Data.Either.Either TigerEscap.Errores)
                     @ s
                     TigerEscap.$fEscapatorStateT_$dFunctor
                     (Data.Either.$fMonadEither @ TigerEscap.Errores))
                  (Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$c<*
                     @ (Data.Either.Either TigerEscap.Errores)
                     @ s
                     TigerEscap.$fEscapatorStateT_$dFunctor
                     (Data.Either.$fMonadEither @ TigerEscap.Errores)) -}
f9cee9f24f5353f978673223b0412ddd
  $fEscapatorStateT_$s$fApplicativeStateT_$c<*> ::
    Control.Monad.Trans.State.Lazy.StateT
      s (Data.Either.Either TigerEscap.Errores) (a -> b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Data.Either.Either TigerEscap.Errores) a
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Data.Either.Either TigerEscap.Errores) b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (ds :: Control.Monad.Trans.State.Lazy.StateT
                            s (Data.Either.Either TigerEscap.Errores) (a -> b))
                   (ds1 :: Control.Monad.Trans.State.Lazy.StateT
                             s (Data.Either.Either TigerEscap.Errores) a) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> Data.Either.Either TigerEscap.Errores (b, s))
                   @ (Control.Monad.Trans.State.Lazy.StateT
                        s (Data.Either.Either TigerEscap.Errores) b)
                   (\ (tpl :: s -> Data.Either.Either TigerEscap.Errores (b, s)) ->
                    tpl)
                     `cast`
                   (<s -> Data.Either.Either TigerEscap.Errores (b, s)>_R
                    ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <s>_N <Data.Either.Either TigerEscap.Errores>_R <b>_N))
                   (\ (s1 :: s) ->
                    Data.Either.$fMonadEither_$c>>=
                      @ TigerEscap.Errores
                      @ (a -> b, s)
                      @ (b, s)
                      (ds
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <s>_N <Data.Either.Either TigerEscap.Errores>_R <a -> b>_N)
                         s1)
                      (\ (ds2 :: (a -> b, s))[OneShot] ->
                       Data.Either.$fMonadEither_$c>>=
                         @ TigerEscap.Errores
                         @ (a, s)
                         @ (b, s)
                         (ds1
                            `cast`
                          (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <Data.Either.Either TigerEscap.Errores>_R <a>_N)
                            (case ds2 of wild { (,) f s' -> s' }))
                         (\ (ds3 :: (a, s))[OneShot] ->
                          Data.Either.$fMonadEither_$creturn
                            @ TigerEscap.Errores
                            @ (b, s)
                            (case ds2 of wild { (,) f s' ->
                             f (case ds3 of wild1 { (,) x s'' -> x }) },
                             case ds3 of wild { (,) x s'' -> s'' }))))) -}
142aa42b91221069edc6ebe5c5d38dba
  $fEscapatorStateT_$s$fApplicativeStateT_$cpure ::
    a
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Data.Either.Either TigerEscap.Errores) a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m2,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ s @ a (a1 :: a) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> Data.Either.Either TigerEscap.Errores (a, s))
                   @ (Control.Monad.Trans.State.Lazy.StateT
                        s (Data.Either.Either TigerEscap.Errores) a)
                   (\ (tpl :: s -> Data.Either.Either TigerEscap.Errores (a, s)) ->
                    tpl)
                     `cast`
                   (<s -> Data.Either.Either TigerEscap.Errores (a, s)>_R
                    ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <s>_N <Data.Either.Either TigerEscap.Errores>_R <a>_N))
                   (\ (s1 :: s) ->
                    Data.Either.$fMonadEither_$creturn
                      @ TigerEscap.Errores
                      @ (a, s)
                      (a1, s1))) -}
7973a09c6df34db607abab515b174000
  $fEscapatorStateT_$s$fMonadStateT ::
    GHC.Base.Monad
      (Control.Monad.Trans.State.Lazy.StateT
         s (Data.Either.Either TigerEscap.Errores))
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s (Data.Either.Either TigerEscap.Errores))
                  (TigerEscap.$fEscapatorStateT_$s$fMonadStateT_$cp1Monad @ s)
                  (TigerEscap.$fEscapatorStateT_$s$fMonadStateT_$c>>= @ s)
                  (TigerEscap.$fEscapatorStateT_$s$fMonadStateT_$c>> @ s)
                  (Control.Monad.Trans.State.Lazy.$fMonadStateT_$creturn
                     @ (Data.Either.Either TigerEscap.Errores)
                     @ s
                     (Data.Either.$fMonadEither @ TigerEscap.Errores))
                  (TigerEscap.$fEscapatorStateT_$s$fMonadStateT_$cfail @ s) -}
5c6d335e259abb8ad8e370da0d01b566
  $fEscapatorStateT_$s$fMonadStateT_$c>> ::
    Control.Monad.Trans.State.Lazy.StateT
      s (Data.Either.Either TigerEscap.Errores) a
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Data.Either.Either TigerEscap.Errores) b
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Data.Either.Either TigerEscap.Errores) b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s (Data.Either.Either TigerEscap.Errores) a)
                   (k :: Control.Monad.Trans.State.Lazy.StateT
                           s (Data.Either.Either TigerEscap.Errores) b) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> Data.Either.Either TigerEscap.Errores (b, s))
                   @ (Control.Monad.Trans.State.Lazy.StateT
                        s (Data.Either.Either TigerEscap.Errores) b)
                   (\ (tpl :: s -> Data.Either.Either TigerEscap.Errores (b, s)) ->
                    tpl)
                     `cast`
                   (<s -> Data.Either.Either TigerEscap.Errores (b, s)>_R
                    ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <s>_N <Data.Either.Either TigerEscap.Errores>_R <b>_N))
                   (\ (s1 :: s) ->
                    Data.Either.$fMonadEither_$c>>=
                      @ TigerEscap.Errores
                      @ (a, s)
                      @ (b, s)
                      (Control.Monad.Trans.State.Lazy.runStateT
                         @ s
                         @ (Data.Either.Either TigerEscap.Errores)
                         @ a
                         m1
                         s1)
                      (\ (ds :: (a, s))[OneShot] ->
                       Control.Monad.Trans.State.Lazy.runStateT
                         @ s
                         @ (Data.Either.Either TigerEscap.Errores)
                         @ b
                         k
                         (case ds of wild { (,) a1 s' -> s' })))) -}
7332dfb095e8d5fb1de495d095628d21
  $fEscapatorStateT_$s$fMonadStateT_$c>>= ::
    Control.Monad.Trans.State.Lazy.StateT
      s (Data.Either.Either TigerEscap.Errores) a
    -> (a
        -> Control.Monad.Trans.State.Lazy.StateT
             s (Data.Either.Either TigerEscap.Errores) b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Data.Either.Either TigerEscap.Errores) b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(C1(U))><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s (Data.Either.Either TigerEscap.Errores) a)
                   (k :: a
                         -> Control.Monad.Trans.State.Lazy.StateT
                              s (Data.Either.Either TigerEscap.Errores) b) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> Data.Either.Either TigerEscap.Errores (b, s))
                   @ (Control.Monad.Trans.State.Lazy.StateT
                        s (Data.Either.Either TigerEscap.Errores) b)
                   (\ (tpl :: s -> Data.Either.Either TigerEscap.Errores (b, s)) ->
                    tpl)
                     `cast`
                   (<s -> Data.Either.Either TigerEscap.Errores (b, s)>_R
                    ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <s>_N <Data.Either.Either TigerEscap.Errores>_R <b>_N))
                   (\ (s1 :: s) ->
                    Data.Either.$fMonadEither_$c>>=
                      @ TigerEscap.Errores
                      @ (a, s)
                      @ (b, s)
                      (Control.Monad.Trans.State.Lazy.runStateT
                         @ s
                         @ (Data.Either.Either TigerEscap.Errores)
                         @ a
                         m1
                         s1)
                      (\ (ds :: (a, s))[OneShot] ->
                       Control.Monad.Trans.State.Lazy.runStateT
                         @ s
                         @ (Data.Either.Either TigerEscap.Errores)
                         @ b
                         (k (case ds of wild { (,) a1 s' -> a1 }))
                         (case ds of wild { (,) a1 s' -> s' })))) -}
df2c35b2ff99beb1b68193a4e2f1c8c5
  $fEscapatorStateT_$s$fMonadStateT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.State.Lazy.StateT
         s (Data.Either.Either TigerEscap.Errores) a
  {- Arity: 2, Strictness: <B,U><B,A>x, Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ s @ a (str :: GHC.Base.String) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> Data.Either.Either TigerEscap.Errores (a, s))
                   @ (Control.Monad.Trans.State.Lazy.StateT
                        s (Data.Either.Either TigerEscap.Errores) a)
                   (\ (tpl :: s -> Data.Either.Either TigerEscap.Errores (a, s)) ->
                    tpl)
                     `cast`
                   (<s -> Data.Either.Either TigerEscap.Errores (a, s)>_R
                    ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <s>_N <Data.Either.Either TigerEscap.Errores>_R <a>_N))
                   (\ (ds :: s) ->
                    Data.Either.$fMonadEither_$cfail
                      @ TigerEscap.Errores
                      @ (a, s)
                      str)) -}
1e1caa4e9a399e7ba88063a4376e0cf2
  $fEscapatorStateT_$s$fMonadStateT_$cp1Monad ::
    GHC.Base.Applicative
      (Control.Monad.Trans.State.Lazy.StateT
         s (Data.Either.Either TigerEscap.Errores))
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                TigerEscap.$fEscapatorStateT_$s$fApplicativeStateT -}
78c90c1e9d5bb18ae29a7d8e145a546f
  $fEscapatorStateT_$s$fShow(,) ::
    GHC.Show.Show (GHC.Types.Int, GHC.Types.Bool)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Types.Int, GHC.Types.Bool)
                  (GHC.Show.$fShow(,)_$cshowsPrec
                     @ GHC.Types.Int
                     @ GHC.Types.Bool
                     GHC.Show.$fShowInt
                     GHC.Show.$fShowBool)
                  TigerEscap.$fEscapatorStateT_$s$fShow(,)_$cshow
                  TigerEscap.$fEscapatorStateT_$s$fShow(,)_$cshowList -}
c53d01e06f583a9b60dba179521c8ea1
  $fEscapatorStateT_$s$fShow(,)_$cshow ::
    (GHC.Types.Int, GHC.Types.Bool) -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(U),U)>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: (GHC.Types.Int, GHC.Types.Bool)) ->
                 GHC.Show.$fShow(,)_$cshowsPrec
                   @ GHC.Types.Int
                   @ GHC.Types.Bool
                   GHC.Show.$fShowInt
                   GHC.Show.$fShowBool
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
f2b5217224fa62582920c2b2bc8415ec
  $fEscapatorStateT_$s$fShow(,)_$cshowList ::
    [(GHC.Types.Int, GHC.Types.Bool)] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [(GHC.Types.Int, GHC.Types.Bool)])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (GHC.Types.Int, GHC.Types.Bool)
                   (GHC.Show.$fShow(,)_$cshowsPrec
                      @ GHC.Types.Int
                      @ GHC.Types.Bool
                      GHC.Show.$fShowInt
                      GHC.Show.$fShowBool
                      GHC.Show.shows22)
                   eta
                   eta1) -}
2ce1adb168dae20860fee0e8582aa84f
  $fShowErrores :: GHC.Show.Show TigerEscap.Errores
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ TigerEscap.Errores
                  TigerEscap.$fShowErrores_$cshowsPrec
                  TigerEscap.$fShowErrores_$cshow
                  TigerEscap.$fShowErrores_$cshowList -}
80831c44d9d07625a3f30c4787de50d1
  $fShowErrores1 :: (GHC.Types.Char -> b -> b) -> b -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U>,
     Unfolding: (\ @ b
                   (c :: GHC.Types.Char -> b -> b)[OneShot]
                   (n :: b)[OneShot] ->
                 GHC.CString.unpackFoldrCString#
                   @ b
                   "No se encuentra la variable "#
                   c
                   n) -}
2ce1adb168dae20860fee0e8582aa84f
  $fShowErrores_$cshow :: TigerEscap.Errores -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: TigerEscap.Errores) ->
                 case ds of wild {
                   TigerEscap.NotFound e1
                   -> TigerEscap.$fShowErrores1
                        @ [GHC.Types.Char]
                        (GHC.Types.: @ GHC.Types.Char)
                        (Data.Text.Show.$fShowText_$cshow e1)
                   TigerEscap.Interno e1
                   -> GHC.CString.unpackAppendCString#
                        "Error interno "#
                        (Data.Text.Show.$fShowText_$cshow e1) }) -}
2ce1adb168dae20860fee0e8582aa84f
  $fShowErrores_$cshowList :: [TigerEscap.Errores] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [TigerEscap.Errores]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ TigerEscap.Errores
                   (TigerEscap.$fShowErrores_$cshowsPrec GHC.Show.shows22)
                   ls
                   s) -}
2ce1adb168dae20860fee0e8582aa84f
  $fShowErrores_$cshowsPrec ::
    GHC.Types.Int -> TigerEscap.Errores -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: TigerEscap.Errores)
                   (w2 :: GHC.Base.String) ->
                 TigerEscap.$w$cshowsPrec1 w1 w2) -}
6eb426d08248788ae90cd6a51a094b0a
  $fShowEstado :: GHC.Show.Show TigerEscap.Estado
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ TigerEscap.Estado
                  TigerEscap.$fShowEstado_$cshowsPrec
                  TigerEscap.$fShowEstado_$cshow
                  TigerEscap.$fShowEstado_$cshowList -}
6eb426d08248788ae90cd6a51a094b0a
  $fShowEstado1 :: TigerEscap.Estado -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ (w :: TigerEscap.Estado) ->
                 case w of ww { TigerEscap.S ww1 ww2 ->
                 TigerEscap.$w$cshowsPrec 0# ww1 ww2 }) -}
6eb426d08248788ae90cd6a51a094b0a
  $fShowEstado_$cshow :: TigerEscap.Estado -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U(U),1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: TigerEscap.Estado) ->
                 TigerEscap.$fShowEstado_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
6eb426d08248788ae90cd6a51a094b0a
  $fShowEstado_$cshowList :: [TigerEscap.Estado] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ TigerEscap.Estado
                   TigerEscap.$fShowEstado1) -}
6eb426d08248788ae90cd6a51a094b0a
  $fShowEstado_$cshowsPrec ::
    GHC.Types.Int -> TigerEscap.Estado -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U(U(U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: TigerEscap.Estado) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { TigerEscap.S ww3 ww4 ->
                 TigerEscap.$w$cshowsPrec ww1 ww3 ww4 } }) -}
b7ca0d735615825b66292a223663a568
  $fShowSEstado :: GHC.Show.Show TigerEscap.SEstado
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ TigerEscap.SEstado
                  TigerEscap.$fShowSEstado_$cshowsPrec
                  TigerEscap.$fShowSEstado_$cshow
                  TigerEscap.$fShowSEstado_$cshowList -}
b7ca0d735615825b66292a223663a568
  $fShowSEstado1 :: TigerEscap.SEstado -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: TigerEscap.SEstado) (w1 :: GHC.Base.String) ->
                 case w of ww { TigerEscap.Step ww1 ww2 ->
                 TigerEscap.$w$cshowsPrec2 0# ww1 ww2 w1 }) -}
7fdaa34cd15f97abe66c7784742f0dd7
  $fShowSEstado2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Step {"#) -}
d85329ffcfa43b91c812283a34cb6ed0
  $fShowSEstado3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "e = "#) -}
22c905b8c4140b6bcd4e0a2dfccef007
  $fShowSEstado4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "l = "#) -}
b7ca0d735615825b66292a223663a568
  $fShowSEstado_$cshow :: TigerEscap.SEstado -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(U),1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: TigerEscap.SEstado) ->
                 TigerEscap.$fShowSEstado_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
b7ca0d735615825b66292a223663a568
  $fShowSEstado_$cshowList :: [TigerEscap.SEstado] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ TigerEscap.SEstado
                   TigerEscap.$fShowSEstado1) -}
b7ca0d735615825b66292a223663a568
  $fShowSEstado_$cshowsPrec ::
    GHC.Types.Int -> TigerEscap.SEstado -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U(1*U(U),1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: TigerEscap.SEstado)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { TigerEscap.Step ww3 ww4 ->
                 TigerEscap.$w$cshowsPrec2 ww1 ww3 ww4 w2 } }) -}
62ac5384867540ce5fb409b9014ae2a9
  $tc'C:Escapator :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17482582590032321956##
                   12165997607829010632##
                   TigerEscap.$trModule
                   TigerEscap.$tc'C:Escapator1) -}
5a181df5ab37aa35b8ce9a27ce88c5c5
  $tc'C:Escapator1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'C:Escapator"#) -}
682f7fa81db772abdee179975ae230c6
  $tc'Interno :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7571804088035412886##
                   11860240286254758185##
                   TigerEscap.$trModule
                   TigerEscap.$tc'Interno1) -}
6e992f3abbe3870dec3de07a169d1da4
  $tc'Interno1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Interno"#) -}
0e2a5cd07d433f72acdb8c846020d7f4
  $tc'NotFound :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7042916083543647500##
                   5301185552927730511##
                   TigerEscap.$trModule
                   TigerEscap.$tc'NotFound1) -}
76c7a93a78a3dedf31be2a3967f9c281
  $tc'NotFound1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NotFound"#) -}
c4a3db93b42a1885caba7f06fbf3fb1c
  $tc'S :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8027564879898349302##
                   10346432672471661344##
                   TigerEscap.$trModule
                   TigerEscap.$tc'S1) -}
e08569fb3c83f382fc8b187c52517d43
  $tc'S1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'S"#) -}
79d4177b5e27b5eb2af4e0f92a662aca
  $tc'Step :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1948636148410016524##
                   17317255890288768918##
                   TigerEscap.$trModule
                   TigerEscap.$tc'Step1) -}
d6deac4b1d5acd9664d139b10c0ff8d4
  $tc'Step1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Step"#) -}
82832fb71efe4ef779366ba81b633a5a
  $tcErrores :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6822808831431376653##
                   4939770915030390251##
                   TigerEscap.$trModule
                   TigerEscap.$tcErrores1) -}
327ad585bf87b5f3e3b21d098456c517
  $tcErrores1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Errores"#) -}
66de87a7c675843883069ce1b7507c3c
  $tcEscapator :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9738232542894455274##
                   11215981768637236756##
                   TigerEscap.$trModule
                   TigerEscap.$tcEscapator1) -}
6e7943d7e0f3506eaeb7a9958554f9ed
  $tcEscapator1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Escapator"#) -}
5c826dc0d50089bb14a29f488fd7eea9
  $tcEstado :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13614065337555173816##
                   6127354894462689117##
                   TigerEscap.$trModule
                   TigerEscap.$tcEstado1) -}
af7dab7866d650428602f806fa60de68
  $tcEstado1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Estado"#) -}
f5525adeaa2d71c0d84e38006a90c484
  $tcSEstado :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8382869776001282328##
                   1784193032077605642##
                   TigerEscap.$trModule
                   TigerEscap.$tcSEstado1) -}
004eef3ecd505a60d3c79bbf4a9b6b26
  $tcSEstado1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "SEstado"#) -}
03ef48c4243786fad4b1fb7842b388ea
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   TigerEscap.$trModule2
                   TigerEscap.$trModule1) -}
98e9f77504a7a67dd2c62a2f7731de7c
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "TigerEscap"#) -}
83ad2cf4be41c3ef353c65f06be30000
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "HaskTiger-0.1.0.0-1NjWJIneMSYKOEJS7DxzEs"#) -}
008ff4a98533bfb74d78c78af28675dc
  $w$cshowsPrec ::
    GHC.Prim.Int# -> GHC.Types.Int -> TigerEscap.Env -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,U><L,U(U)><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: TigerEscap.Env) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = Data.Map.Base.$w$cshowsPrec
                       @ Data.Text.Internal.Text
                       @ (GHC.Types.Int, GHC.Types.Bool)
                       Data.Text.Show.$fShowText
                       TigerEscap.$fEscapatorStateT_$s$fShow(,)
                       0#
                       ww2
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       TigerEscap.$fEscapatorStateT11
                       (GHC.Base.++
                          @ GHC.Types.Char
                          TigerEscap.$fEscapatorStateT10
                          (case ww1 of ww3 { GHC.Types.I# ww4 ->
                           case GHC.Show.$wshowSignedInt
                                  0#
                                  ww4
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     TigerEscap.$fEscapatorStateT9
                                     (GHC.Base.++
                                        @ GHC.Types.Char
                                        TigerEscap.$fEscapatorStateT8
                                        (f (GHC.Base.++
                                              @ GHC.Types.Char
                                              TigerEscap.$fEscapatorStateT7
                                              x)))) of ww5 { (#,#) ww6 ww7 ->
                           GHC.Types.: @ GHC.Types.Char ww6 ww7 } }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x)) }) -}
2ce1adb168dae20860fee0e8582aa84f
  $w$cshowsPrec1 ::
    TigerEscap.Errores -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: TigerEscap.Errores) (w1 :: GHC.Base.String) ->
                 case w of wild {
                   TigerEscap.NotFound e1
                   -> TigerEscap.$fShowErrores1
                        @ [GHC.Types.Char]
                        (GHC.Types.: @ GHC.Types.Char)
                        (case Data.Text.Show.$w$cshow e1 of ww { (#,#) ww1 ww2 ->
                         GHC.Base.++
                           @ GHC.Types.Char
                           (GHC.Types.: @ GHC.Types.Char ww1 ww2)
                           w1 })
                   TigerEscap.Interno e1
                   -> GHC.CString.unpackAppendCString#
                        "Error interno "#
                        (case Data.Text.Show.$w$cshow e1 of ww { (#,#) ww1 ww2 ->
                         GHC.Base.++
                           @ GHC.Types.Char
                           (GHC.Types.: @ GHC.Types.Char ww1 ww2)
                           w1 }) }) -}
749781164bf7957eda4edccaf0bb658c
  $w$cshowsPrec2 ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> [TigerEscap.Env]
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <S,U><L,1*U(U)><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: [TigerEscap.Env])
                   (w :: GHC.Base.String) ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (x :: GHC.Base.String)[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       TigerEscap.$fShowSEstado4
                       (case ww1 of ww3 { GHC.Types.I# ww4 ->
                        case GHC.Show.$wshowSignedInt
                               0#
                               ww4
                               (GHC.Base.++
                                  @ GHC.Types.Char
                                  TigerEscap.$fEscapatorStateT9
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     TigerEscap.$fShowSEstado3
                                     (let {
                                        s :: GHC.Base.String
                                        = GHC.Base.++
                                            @ GHC.Types.Char
                                            TigerEscap.$fEscapatorStateT7
                                            x
                                      } in
                                      case ww2 of wild {
                                        [] -> GHC.CString.unpackAppendCString# "[]"# s
                                        : x1 xs
                                        -> GHC.Types.:
                                             @ GHC.Types.Char
                                             GHC.Show.showList__2
                                             (Data.Map.Base.$w$cshowsPrec
                                                @ Data.Text.Internal.Text
                                                @ (GHC.Types.Int, GHC.Types.Bool)
                                                Data.Text.Show.$fShowText
                                                TigerEscap.$fEscapatorStateT_$s$fShow(,)
                                                0#
                                                x1
                                                (let {
                                                   lvl27 :: [GHC.Types.Char]
                                                   = GHC.Types.:
                                                       @ GHC.Types.Char
                                                       GHC.Show.showList__1
                                                       s
                                                 } in
                                                 letrec {
                                                   showl :: [Data.Map.Base.Map
                                                               Data.Text.Internal.Text
                                                               (GHC.Types.Int, GHC.Types.Bool)]
                                                            -> GHC.Base.String
                                                     {- Arity: 1, Strictness: <S,1*U> -}
                                                   = \ (ds2 :: [Data.Map.Base.Map
                                                                  Data.Text.Internal.Text
                                                                  (GHC.Types.Int,
                                                                   GHC.Types.Bool)]) ->
                                                     case ds2 of wild1 {
                                                       [] -> lvl27
                                                       : y ys
                                                       -> GHC.Types.:
                                                            @ GHC.Types.Char
                                                            GHC.Show.shows5
                                                            (Data.Map.Base.$w$cshowsPrec
                                                               @ Data.Text.Internal.Text
                                                               @ (GHC.Types.Int, GHC.Types.Bool)
                                                               Data.Text.Show.$fShowText
                                                               TigerEscap.$fEscapatorStateT_$s$fShow(,)
                                                               0#
                                                               y
                                                               (showl ys)) }
                                                 } in
                                                 showl xs)) }))) of ww5 { (#,#) ww6 ww7 ->
                        GHC.Types.: @ GHC.Types.Char ww6 ww7 } })
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> GHC.Base.++ @ GHC.Types.Char TigerEscap.$fShowSEstado2 (g w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (GHC.Base.++
                           @ GHC.Types.Char
                           TigerEscap.$fShowSEstado2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 w))) }) -}
ff2f96018d444711844e6500b844cd59
  $w$cupdate ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Types.Bool
    -> GHC.Types.Int
    -> TigerEscap.Env
    -> Data.Either.Either TigerEscap.Errores ((), TigerEscap.Estado)
  {- Arity: 6, Strictness: <L,U><L,U><L,U><L,U><L,U><S,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (w :: GHC.Types.Bool)
                   (ww3 :: GHC.Types.Int)
                   (ww4 :: TigerEscap.Env) ->
                 case TigerEscap.$wpoly_go10
                        @ (GHC.Types.Int, GHC.Types.Bool)
                        ww
                        ww1
                        ww2
                        ww4 of wild {
                   GHC.Base.Nothing
                   -> Data.Either.Left
                        @ TigerEscap.Errores
                        @ ((), TigerEscap.Estado)
                        (TigerEscap.Interno
                           (TigerSymbol.addStr
                              TigerEscap.$fDaemonStateT_g2
                              (Data.Text.Internal.Text ww ww1 ww2)))
                   GHC.Base.Just x
                   -> case x of wild1 { (,) lvl13 ds ->
                      Data.Either.Right
                        @ TigerEscap.Errores
                        @ ((), TigerEscap.Estado)
                        (GHC.Tuple.(),
                         TigerEscap.S
                           ww3
                           (TigerEscap.$w$sgo4
                              @ (GHC.Types.Int, GHC.Types.Bool)
                              ww
                              ww1
                              ww2
                              (lvl13, w)
                              ww4)) } }) -}
873bba1fd6eddd2ccf6aee6e3405dacf
  $w$sgo4 ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> a1
    -> Data.Map.Base.Map TigerSymbol.Symbol a1
    -> Data.Map.Base.Map TigerSymbol.Symbol a1
  {- Arity: 5, Strictness: <L,U><L,U><L,U><S,1*U><S,1*U>,
     Inline: [0] -}
ba8c22c6ff8b910277c75a4b38db23fa
  $w$stravF ::
    TigerSymbol.Symbol
    -> [TigerAbs.Field]
    -> GHC.Base.Maybe TigerSymbol.Symbol
    -> TigerAbs.Exp
    -> TigerAbs.Pos
    -> Control.Monad.Trans.State.Lazy.StateT
         TigerEscap.Estado
         (Data.Either.Either TigerEscap.Errores)
         (TigerSymbol.Symbol, [TigerAbs.Field],
          GHC.Base.Maybe TigerSymbol.Symbol, TigerAbs.Exp, TigerAbs.Pos)
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,1*U><L,U>,
     Inline: [0] -}
838086c2ed6a4695568f0332fe35a9ed
  $wpoly_go10 ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Map.Base.Map TigerSymbol.Symbol a
    -> GHC.Base.Maybe a
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,U><L,U><S,1*U>,
     Inline: [0] -}
fa6924179d45548589b0f8097e755ac3
  $wtravF ::
    TigerEscap.Escapator m =>
    TigerSymbol.Symbol
    -> [TigerAbs.Field]
    -> GHC.Base.Maybe TigerSymbol.Symbol
    -> TigerAbs.Exp
    -> TigerAbs.Pos
    -> m (TigerSymbol.Symbol, [TigerAbs.Field],
          GHC.Base.Maybe TigerSymbol.Symbol, TigerAbs.Exp, TigerAbs.Pos)
  {- Arity: 6,
     Strictness: <S(LSLLLLLLL),U(U(U,U,U,U,U),U(U,U,U,U,U),U,C(U),A,A,C(C1(U)),C(U),C(C1(C1(U))))><L,U><L,U><L,U><L,1*U><L,U>,
     Inline: [0] -}
926c7869b2d8f7d5eaf6119e9effefb3
  type Dat = (GHC.Types.Int, GHC.Types.Bool)
b9d18f47fdaa7df76fa1c3e043c6165e
  type Depth = GHC.Types.Int
ce63260c3d52b15438ec07e155452d65
  type Env = Data.Map.Base.Map TigerSymbol.Symbol TigerEscap.Dat
2ce1adb168dae20860fee0e8582aa84f
  data Errores
    = NotFound TigerSymbol.Symbol | Interno TigerSymbol.Symbol
1a28e4bddfed5e0884e7fcc76790746c
  class (TigerErrores.Daemon m, GHC.Base.Monad m) =>
        Escapator (m :: * -> *) where
    depth :: m TigerEscap.Depth
    up :: m a -> m a
    printEnv :: m ()
    raise :: TigerSymbol.Symbol -> m a
    update :: TigerSymbol.Symbol -> GHC.Types.Bool -> m ()
    lookup :: TigerSymbol.Symbol
              -> m (GHC.Base.Maybe (GHC.Types.Int, GHC.Types.Bool))
    insert :: TigerSymbol.Symbol -> GHC.Types.Bool -> m a -> m a
    {-# MINIMAL depth, up, printEnv, update, lookup, insert #-}
6eb426d08248788ae90cd6a51a094b0a
  data Estado = S {lvl :: GHC.Types.Int, env :: TigerEscap.Env}
2ce1adb168dae20860fee0e8582aa84f
  type Mini =
    Control.Monad.Trans.State.Lazy.StateT
      TigerEscap.Estado (Data.Either.Either TigerEscap.Errores)
    :: * -> *
b7ca0d735615825b66292a223663a568
  data SEstado = Step {l :: GHC.Types.Int, e :: [TigerEscap.Env]}
f7f1a9c6a9b15facd0aa633d23d827f5
  bulkInsert ::
    TigerEscap.Escapator m =>
    [(TigerSymbol.Symbol, GHC.Types.Bool)] -> m a -> m a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,C(C1(C1(U))))><S,1*U><L,U>,
     Unfolding: (\ @ (m :: * -> *)
                   @ a
                   ($dEscapator :: TigerEscap.Escapator m)
                   (xs :: [(TigerSymbol.Symbol, GHC.Types.Bool)])
                   (m1 :: m a) ->
                 letrec {
                   go5 :: [(TigerSymbol.Symbol, GHC.Types.Bool)] -> m a
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [(TigerSymbol.Symbol, GHC.Types.Bool)]) ->
                     case ds of wild {
                       [] -> m1
                       : y ys
                       -> case y of wild1 { (,) name esc ->
                          TigerEscap.insert @ m $dEscapator @ a name esc (go5 ys) } }
                 } in
                 go5 xs) -}
a4a801979c81bbbd2b8a75cf0185f3b7
  calcularEEsc ::
    TigerAbs.Exp -> Data.Either.Either TigerEscap.Errores TigerAbs.Exp
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (e1 :: TigerAbs.Exp) ->
                 case (TigerEscap.calcularEEsc_$stravExp e1)
                        `cast`
                      (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <TigerEscap.Estado>_N
                           <Data.Either.Either TigerEscap.Errores>_R
                           <TigerAbs.Exp>_N)
                        TigerEscap.initSt of wild {
                   Data.Either.Left l1
                   -> Data.Either.Left @ TigerEscap.Errores @ TigerAbs.Exp l1
                   Data.Either.Right r
                   -> Data.Either.Right
                        @ TigerEscap.Errores
                        @ TigerAbs.Exp
                        (case r of wild1 { (,) a1 ds1 -> a1 }) }) -}
1bcf2ce35a2c76ae617f9a8d8f4da94e
  calcularEEsc_$stravExp ::
    TigerAbs.Exp
    -> Control.Monad.Trans.State.Lazy.StateT
         TigerEscap.Estado
         (Data.Either.Either TigerEscap.Errores)
         TigerAbs.Exp
  {- Arity: 1, Strictness: <S,1*U> -}
7a01e1610b55acacb4f0b88813c9c43a
  e :: TigerEscap.SEstado -> [TigerEscap.Env]
  RecSel Left TigerEscap.SEstado
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: TigerEscap.SEstado) ->
                 case ds of wild { TigerEscap.Step ds1 ds2 -> ds2 }) -}
2ce1adb168dae20860fee0e8582aa84f
  eappend ::
    TigerEscap.Errores -> Data.Text.Internal.Text -> TigerEscap.Errores
  {- Arity: 2, Strictness: <S,1*U><L,1*U(U,U,U)>,
     Unfolding: (\ (ds :: TigerEscap.Errores)
                   (e1 :: Data.Text.Internal.Text) ->
                 case ds of wild {
                   TigerEscap.NotFound e2
                   -> TigerEscap.NotFound (Data.Text.append e2 e1)
                   TigerEscap.Interno e2
                   -> TigerEscap.Interno (Data.Text.append e2 e1) }) -}
1b78fd6e287a4e4833d961105d8b6f82
  env :: TigerEscap.Estado -> TigerEscap.Env
  RecSel Left TigerEscap.Estado
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: TigerEscap.Estado) ->
                 case ds of wild { TigerEscap.S ds1 ds2 -> ds2 }) -}
f2f667c5afbe6d178c38412e15dd6527
  initSt :: TigerEscap.Estado
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (TigerEscap.S
                   TigerEscap.initSt1
                   (Data.Map.Base.Tip @ TigerSymbol.Symbol @ TigerEscap.Dat)) -}
3abe9a8c77b882129e2f733550338335
  initSt1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
a83ea91aeafa0ab006f3a3e9529d378f
  l :: TigerEscap.SEstado -> GHC.Types.Int
  RecSel Left TigerEscap.SEstado
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U(U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: TigerEscap.SEstado) ->
                 case ds of wild { TigerEscap.Step ds1 ds2 -> ds1 }) -}
afda6125e00eae06477a6696f73b739a
  lookUpLvl ::
    TigerEscap.Escapator m => TigerSymbol.Symbol -> m GHC.Types.Int
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LSLLLLLLL),U(1*U(A,A,1*C1(U),A,A),1*U,A,A,A,A,A,1*C1(U),A)><L,U>,
     Unfolding: (\ @ (m :: * -> *)
                   ($dEscapator :: TigerEscap.Escapator m)
                   (eta :: TigerSymbol.Symbol) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = TigerEscap.$p2Escapator @ m $dEscapator
                 } in
                 let {
                   lvl13 :: m GHC.Types.Int
                   = TigerErrores.notfound
                       @ m
                       (TigerEscap.$p1Escapator @ m $dEscapator)
                       @ GHC.Types.Int
                       eta
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (GHC.Base.Maybe (GHC.Types.Int, GHC.Types.Bool))
                   @ GHC.Types.Int
                   (TigerEscap.lookup @ m $dEscapator eta)
                   (\ (ds :: GHC.Base.Maybe (GHC.Types.Int, GHC.Types.Bool)) ->
                    case ds of wild {
                      GHC.Base.Nothing -> lvl13
                      GHC.Base.Just ds1
                      -> case ds1 of wild1 { (,) l1 esc ->
                         GHC.Base.return @ m $dMonad @ GHC.Types.Int l1 } })) -}
79147e47f8ee05b34f966ea074baed9b
  lookUpLvl_$slookUpLvl ::
    TigerSymbol.Symbol
    -> Control.Monad.Trans.State.Lazy.StateT
         TigerEscap.Estado
         (Data.Either.Either TigerEscap.Errores)
         GHC.Types.Int
  {- Arity: 1, Strictness: <L,U(U,U,U)>,
     Unfolding: (\ (eta :: TigerSymbol.Symbol) ->
                 let {
                   x :: TigerSymbol.Symbol
                   = TigerSymbol.addStr TigerEscap.$fDaemonStateT_g2 eta
                 } in
                 let {
                   lvl13 :: TigerEscap.Errores = TigerEscap.Interno x
                 } in
                 let {
                   lvl14 :: Data.Either.Either
                              TigerEscap.Errores (GHC.Types.Int, TigerEscap.Estado)
                   = Data.Either.Left
                       @ TigerEscap.Errores
                       @ (GHC.Types.Int, TigerEscap.Estado)
                       lvl13
                 } in
                 (\ (s1 :: TigerEscap.Estado) ->
                  case eta of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                  case s1 of wild { TigerEscap.S ds ds1 ->
                  case TigerEscap.$wpoly_go10
                         @ (GHC.Types.Int, GHC.Types.Bool)
                         ww1
                         ww2
                         ww3
                         ds1 of wild1 {
                    GHC.Base.Nothing -> lvl14
                    GHC.Base.Just ds2
                    -> case ds2 of wild2 { (,) l1 esc ->
                       Data.Either.Right
                         @ TigerEscap.Errores
                         @ (GHC.Types.Int, TigerEscap.Estado)
                         (l1, wild) } } } })
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <TigerEscap.Estado>_N
                           <Data.Either.Either TigerEscap.Errores>_R
                           <GHC.Types.Int>_N))) -}
bf3bff6ac164bbb03ddff1312b65d3cb
  lvl :: TigerEscap.Estado -> GHC.Types.Int
  RecSel Left TigerEscap.Estado
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U(U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: TigerEscap.Estado) ->
                 case ds of wild { TigerEscap.S ds1 ds2 -> ds1 }) -}
0ef87f52da54c66f85094a61f6312e19
  travDecs :: TigerEscap.Escapator m => [TigerAbs.Dec] -> m a -> m a
  {- Arity: 3,
     Strictness: <L,U(U(U,U,U,U,U),U(U,U,U,U,U),U,C(U),A,A,C(C1(U)),C(U),C(C1(C1(U))))><S,1*U><L,1*U> -}
32523b809b3f1f69dc8821a5be8d33bf
  travDecs_$stravDecs ::
    [TigerAbs.Dec]
    -> Control.Monad.Trans.State.Lazy.StateT
         TigerEscap.Estado (Data.Either.Either TigerEscap.Errores) a
    -> Control.Monad.Trans.State.Lazy.StateT
         TigerEscap.Estado (Data.Either.Either TigerEscap.Errores) a
  {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
47b976920c456338d27be6754c63c023
  travExp :: TigerEscap.Escapator m => TigerAbs.Exp -> m TigerAbs.Exp
  {- Arity: 2,
     Strictness: <S(LSLLLLLLL),U(U(U,U,U,U,U),U(U,U,U,U,U),U,C(U),A,A,C(C1(U)),C(U),C(C1(C1(U))))><S,1*U> -}
87ef41924a0bd30868b2ece5a1f15859
  travF ::
    TigerEscap.Escapator m =>
    (TigerSymbol.Symbol, [TigerAbs.Field],
     GHC.Base.Maybe TigerSymbol.Symbol, TigerAbs.Exp, TigerAbs.Pos)
    -> m (TigerSymbol.Symbol, [TigerAbs.Field],
          GHC.Base.Maybe TigerSymbol.Symbol, TigerAbs.Exp, TigerAbs.Pos)
  {- Arity: 2,
     Strictness: <S(LSLLLLLLL),U(U(U,U,U,U,U),U(U,U,U,U,U),U,C(U),A,A,C(C1(U)),C(U),C(C1(C1(U))))><S,1*U(U,U,U,1*U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ (m :: * -> *)
                   (w :: TigerEscap.Escapator m)
                   (w1 :: (TigerSymbol.Symbol, [TigerAbs.Field],
                           GHC.Base.Maybe TigerSymbol.Symbol, TigerAbs.Exp, TigerAbs.Pos)) ->
                 case w1 of ww { (,,,,) ww1 ww2 ww3 ww4 ww5 ->
                 TigerEscap.$wtravF @ m w ww1 ww2 ww3 ww4 ww5 }) -}
264b865ec9e768f9492b7a8dcb68b49d
  travVar :: TigerEscap.Escapator m => TigerAbs.Var -> m TigerAbs.Var
  {- Arity: 2,
     Strictness: <S(LSLLLLLLL),U(U(U,U,U,U,U),U(U,U,U,U,U),U,C(U),A,A,C(C1(U)),C(U),C(C1(C1(U))))><S,1*U> -}
1fb7d2561bd0fdc23f5542a4e16b8d9b
  travVar_$stravVar ::
    TigerAbs.Var
    -> Control.Monad.Trans.State.Lazy.StateT
         TigerEscap.Estado
         (Data.Either.Either TigerEscap.Errores)
         TigerAbs.Var
  {- Arity: 1, Strictness: <S,1*U> -}
instance TigerErrores.Daemon [Control.Monad.Trans.State.Lazy.StateT]
  = TigerEscap.$fDaemonStateT
instance TigerEscap.Escapator [Control.Monad.Trans.State.Lazy.StateT]
  = TigerEscap.$fEscapatorStateT
instance GHC.Show.Show [TigerEscap.Errores]
  = TigerEscap.$fShowErrores
instance GHC.Show.Show [TigerEscap.Estado]
  = TigerEscap.$fShowEstado
instance GHC.Show.Show [TigerEscap.SEstado]
  = TigerEscap.$fShowSEstado
"SPEC lookUpLvl @ (StateT Estado (Either Errores))" [ALWAYS] forall ($dEscapator :: TigerEscap.Escapator
                                                                                      (Control.Monad.Trans.State.Lazy.StateT
                                                                                         TigerEscap.Estado
                                                                                         (Data.Either.Either
                                                                                            TigerEscap.Errores)))
  TigerEscap.lookUpLvl @ (Control.Monad.Trans.State.Lazy.StateT
                            TigerEscap.Estado (Data.Either.Either TigerEscap.Errores))
                       $dEscapator
  = TigerEscap.lookUpLvl_$slookUpLvl
"SPEC travDecs @ (StateT Estado (Either Errores)) _" [ALWAYS] forall @ a
                                                                     ($dEscapator :: TigerEscap.Escapator
                                                                                       (Control.Monad.Trans.State.Lazy.StateT
                                                                                          TigerEscap.Estado
                                                                                          (Data.Either.Either
                                                                                             TigerEscap.Errores)))
  TigerEscap.travDecs @ (Control.Monad.Trans.State.Lazy.StateT
                           TigerEscap.Estado (Data.Either.Either TigerEscap.Errores))
                      @ a
                      $dEscapator
  = TigerEscap.travDecs_$stravDecs @ a
"SPEC travExp @ (StateT Estado (Either Errores))" [ALWAYS] forall ($dEscapator :: TigerEscap.Escapator
                                                                                    (Control.Monad.Trans.State.Lazy.StateT
                                                                                       TigerEscap.Estado
                                                                                       (Data.Either.Either
                                                                                          TigerEscap.Errores)))
  TigerEscap.travExp @ (Control.Monad.Trans.State.Lazy.StateT
                          TigerEscap.Estado (Data.Either.Either TigerEscap.Errores))
                     $dEscapator
  = TigerEscap.calcularEEsc_$stravExp
"SPEC travVar @ (StateT Estado (Either Errores))" [ALWAYS] forall ($dEscapator :: TigerEscap.Escapator
                                                                                    (Control.Monad.Trans.State.Lazy.StateT
                                                                                       TigerEscap.Estado
                                                                                       (Data.Either.Either
                                                                                          TigerEscap.Errores)))
  TigerEscap.travVar @ (Control.Monad.Trans.State.Lazy.StateT
                          TigerEscap.Estado (Data.Either.Either TigerEscap.Errores))
                     $dEscapator
  = TigerEscap.travVar_$stravVar
"SPEC/TigerEscap $fApplicativeStateT @ (Either Errores) _" [ALWAYS] forall @ s
                                                                           ($dMonad :: GHC.Base.Monad
                                                                                         (Data.Either.Either
                                                                                            TigerEscap.Errores))
                                                                           ($dFunctor :: GHC.Base.Functor
                                                                                           (Data.Either.Either
                                                                                              TigerEscap.Errores))
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT @ (Data.Either.Either
                                                          TigerEscap.Errores)
                                                     @ s
                                                     $dFunctor
                                                     $dMonad
  = TigerEscap.$fEscapatorStateT_$s$fApplicativeStateT @ s
"SPEC/TigerEscap $fApplicativeStateT_$c<*> @ (Either Errores) _" [ALWAYS] forall @ s
                                                                                 ($dMonad :: GHC.Base.Monad
                                                                                               (Data.Either.Either
                                                                                                  TigerEscap.Errores))
                                                                                 ($dFunctor :: GHC.Base.Functor
                                                                                                 (Data.Either.Either
                                                                                                    TigerEscap.Errores))
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$c<*> @ (Data.Either.Either
                                                                TigerEscap.Errores)
                                                           @ s
                                                           $dFunctor
                                                           $dMonad
  = TigerEscap.$fEscapatorStateT_$s$fApplicativeStateT_$c<*> @ s
"SPEC/TigerEscap $fApplicativeStateT_$cpure @ (Either Errores) _" [ALWAYS] forall @ s
                                                                                  ($dMonad :: GHC.Base.Monad
                                                                                                (Data.Either.Either
                                                                                                   TigerEscap.Errores))
                                                                                  ($dFunctor :: GHC.Base.Functor
                                                                                                  (Data.Either.Either
                                                                                                     TigerEscap.Errores))
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$cpure @ (Data.Either.Either
                                                                 TigerEscap.Errores)
                                                            @ s
                                                            $dFunctor
                                                            $dMonad
  = TigerEscap.$fEscapatorStateT_$s$fApplicativeStateT_$cpure @ s
"SPEC/TigerEscap $fMonadStateT @ (Either Errores) _" [ALWAYS] forall @ s
                                                                     ($dMonad :: GHC.Base.Monad
                                                                                   (Data.Either.Either
                                                                                      TigerEscap.Errores))
  Control.Monad.Trans.State.Lazy.$fMonadStateT @ (Data.Either.Either
                                                    TigerEscap.Errores)
                                               @ s
                                               $dMonad
  = TigerEscap.$fEscapatorStateT_$s$fMonadStateT @ s
"SPEC/TigerEscap $fMonadStateT_$c>> @ (Either Errores) _" [ALWAYS] forall @ s
                                                                          ($dMonad :: GHC.Base.Monad
                                                                                        (Data.Either.Either
                                                                                           TigerEscap.Errores))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>> @ (Data.Either.Either
                                                         TigerEscap.Errores)
                                                    @ s
                                                    $dMonad
  = TigerEscap.$fEscapatorStateT_$s$fMonadStateT_$c>> @ s
"SPEC/TigerEscap $fMonadStateT_$c>>= @ (Either Errores) _" [ALWAYS] forall @ s
                                                                           ($dMonad :: GHC.Base.Monad
                                                                                         (Data.Either.Either
                                                                                            TigerEscap.Errores))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>>= @ (Data.Either.Either
                                                          TigerEscap.Errores)
                                                     @ s
                                                     $dMonad
  = TigerEscap.$fEscapatorStateT_$s$fMonadStateT_$c>>= @ s
"SPEC/TigerEscap $fMonadStateT_$cfail @ (Either Errores) _" [ALWAYS] forall @ s
                                                                            ($dMonad :: GHC.Base.Monad
                                                                                          (Data.Either.Either
                                                                                             TigerEscap.Errores))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$cfail @ (Data.Either.Either
                                                           TigerEscap.Errores)
                                                      @ s
                                                      $dMonad
  = TigerEscap.$fEscapatorStateT_$s$fMonadStateT_$cfail @ s
"SPEC/TigerEscap $fMonadStateT_$cp1Monad @ (Either Errores) _" [ALWAYS] forall @ s
                                                                               ($dMonad :: GHC.Base.Monad
                                                                                             (Data.Either.Either
                                                                                                TigerEscap.Errores))
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$cp1Monad @ (Data.Either.Either
                                                              TigerEscap.Errores)
                                                         @ s
                                                         $dMonad
  = TigerEscap.$fEscapatorStateT_$s$fMonadStateT_$cp1Monad @ s
"SPEC/TigerEscap $fShow(,) @ Int @ Bool" [ALWAYS] forall ($dShow1 :: GHC.Show.Show
                                                                       GHC.Types.Bool)
                                                         ($dShow :: GHC.Show.Show GHC.Types.Int)
  GHC.Show.$fShow(,) @ GHC.Types.Int @ GHC.Types.Bool $dShow $dShow1
  = TigerEscap.$fEscapatorStateT_$s$fShow(,)
"SPEC/TigerEscap $fShow(,)_$cshow @ Int @ Bool" [ALWAYS] forall ($dShow1 :: GHC.Show.Show
                                                                              GHC.Types.Bool)
                                                                ($dShow :: GHC.Show.Show
                                                                             GHC.Types.Int)
  GHC.Show.$fShow(,)_$cshow @ GHC.Types.Int
                            @ GHC.Types.Bool
                            $dShow
                            $dShow1
  = TigerEscap.$fEscapatorStateT_$s$fShow(,)_$cshow
"SPEC/TigerEscap $fShow(,)_$cshowList @ Int @ Bool" [ALWAYS] forall ($dShow1 :: GHC.Show.Show
                                                                                  GHC.Types.Bool)
                                                                    ($dShow :: GHC.Show.Show
                                                                                 GHC.Types.Int)
  GHC.Show.$fShow(,)_$cshowList @ GHC.Types.Int
                                @ GHC.Types.Bool
                                $dShow
                                $dShow1
  = TigerEscap.$fEscapatorStateT_$s$fShow(,)_$cshowList
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

